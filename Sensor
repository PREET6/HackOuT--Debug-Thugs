const { connection } = require('../config/database');

class Sensor {
  constructor(id, name, type, location, status, last_read, created_at) {
    this.id = id;
    this.name = name;
    this.type = type;
    this.location = location;
    this.status = status;
    this.last_read = last_read;
    this.created_at = created_at;
  }

  // Find sensor by ID
  static findById(id, callback) {
    const query = `
      SELECT 
        id, 
        name, 
        type, 
        ST_X(location) as lat, 
        ST_Y(location) as lng, 
        status, 
        last_read, 
        created_at 
      FROM sensors 
      WHERE id = ?
    `;
    
    connection.query(query, [id], (err, results) => {
      if (err) return callback(err);
      if (results.length === 0) return callback(null, null);
      
      const sensorData = results[0];
      const sensor = new Sensor(
        sensorData.id,
        sensorData.name,
        sensorData.type,
        { lat: sensorData.lat, lng: sensorData.lng },
        sensorData.status,
        sensorData.last_read,
        sensorData.created_at
      );
      
      callback(null, sensor);
    });
  }

  // Get all sensors
  static findAll(filters = {}, page = 1, limit = 10, callback) {
    let query = `
      SELECT 
        id, 
        name, 
        type, 
        ST_X(location) as lat, 
        ST_Y(location) as lng, 
        status, 
        last_read, 
        created_at 
      FROM sensors 
      WHERE 1=1
    `;
    
    let countQuery = 'SELECT COUNT(*) as total FROM sensors WHERE 1=1';
    const queryParams = [];
    const countParams = [];
    
    if (filters.type) {
      query += ' AND type = ?';
      countQuery += ' AND type = ?';
      queryParams.push(filters.type);
      countParams.push(filters.type);
    }
    
    if (filters.status) {
      query += ' AND status = ?';
      countQuery += ' AND status = ?';
      queryParams.push(filters.status);
      countParams.push(filters.status);
    }
    
    const offset = (page - 1) * limit;
    query += ' ORDER BY name LIMIT ? OFFSET ?';
    queryParams.push(parseInt(limit), parseInt(offset));
    
    // Get total count
    connection.query(countQuery, countParams, (err, countResults) => {
      if (err) return callback(err);
      
      const total = countResults[0].total;
      
      // Get paginated results
      connection.query(query, queryParams, (err, results) => {
        if (err) return callback(err);
        
        const sensors = results.map(row => new Sensor(
          row.id,
          row.name,
          row.type,
          { lat: row.lat, lng: row.lng },
          row.status,
          row.last_read,
          row.created_at
        ));
        
        callback(null, {
          sensors,
          pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total,
            pages: Math.ceil(total / limit)
          }
        });
      });
    });
  }

  // Create new sensor
  static create(sensorData, callback) {
    const query = 'INSERT INTO sensors (name, type, location, status) VALUES (?, ?, POINT(?, ?), ?)';
    connection.query(query, 
      [sensorData.name, sensorData.type, sensorData.lat, sensorData.lng, sensorData.status || 'active'], 
      (err, results) => {
        if (err) return callback(err);
        
        callback(null, results.insertId);
      }
    );
  }

  // Update sensor
  update(callback) {
    const query = 'UPDATE sensors SET name = ?, status = ?, location = POINT(?, ?) WHERE id = ?';
    connection.query(query, 
      [this.name, this.status, this.location.lat, this.location.lng, this.id], 
      (err, results) => {
        if (err) return callback(err);
        
        callback(null, results.affectedRows);
      }
    );
  }

  // Delete sensor
  delete(callback) {
    const query = 'DELETE FROM sensors WHERE id = ?';
    connection.query(query, [this.id], (err, results) => {
      if (err) return callback(err);
      
      callback(null, results.affectedRows);
    });
  }
}

module.exports = Sensor;